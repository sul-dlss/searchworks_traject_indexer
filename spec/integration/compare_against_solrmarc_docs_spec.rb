require 'spec_helper'

describe 'comparing against a well-known location full of documents generated by solrmarc' do
  subject(:result) { indexer.map_record(record) }

  let(:indexer) { cached_indexer('./lib/traject/config/sirsi_config.rb') }
  let(:record) { MARC::XMLReader.new(StringIO.new(marcxml)).to_a.first }
  let(:copy_fields) { %w[collection_search pub_date_search db_az_subject_search instructor course topic_display subject_other_display title_variant_display summary_display pub_display] }
  let(:ignored_fields) { %w[created last_updated format _version_ author_sort callnum_facet_hsim marcbib_xml fund_facet] + copy_fields }
  let(:pending_fields) { %w[reverse_shelfkey shelfkey preferred_barcode item_display] }
  subject(:result) { indexer.map_record(record).transform_values { |v| v.sort } }

  Dir.glob(File.expand_path('solrmarc_example_docs/*', file_fixture_path)).each do |fixture|
    context "with #{fixture}" do
      let(:file) { File.read(fixture) }
      let(:data) { JSON.parse(file) }
      let(:solrmarc_doc) { data['doc'] }
      let(:expected_doc) do
        data['doc'].transform_values { |v| Array(v).map(&:to_s).sort }
      end
      let(:marcxml) { solrmarc_doc['marcxml'] }

      it 'maps the same general output' do
        # Stub the year so this test doesn't fail every January
        allow_any_instance_of(Time).to receive(:year).and_return(2019)
        expect(result).to include expected_doc.reject { |k, v| (ignored_fields + pending_fields).include? k }
      end

      it 'maps the same general output' do
        skip unless pending_fields.any?
        pending
        expect(result.select { |k, v| pending_fields.include? k}).to include expected_doc.select { |k, v| pending_fields.include? k }
        expect(false).to eq true # keep rspec happy if the above happens to pass
      end
    end
  end

  if ENV['SOLRMARC_STORED_FIELDS_SOLR_BASE_URL']
    $start = ENV.fetch('start', '0').to_i
    $limit = $start + ENV.fetch('limit', '100000').to_i
    $rows = [500, $limit].min

    if ENV['DONT_OUTPUT_DIFF_CONTEXT_LINES']
      require 'rspec/support/hunk_generator'
      class RSpec::Support::HunkGenerator
        def context_lines; 0; end
      end
    end

    class KindaLike < RSpec::Matchers::BuiltIn::Include
      attr_reader :except_for

      def initialize(expected, except_for: [])
        @except_for = except_for
        super(expected.reject { |k, v| (k =~ /(unstem|exact)_search/ && k != 'series_exact_search') || k =~ /cjk_/ || (except_for).include?(k) }.transform_values { |v| Array(v).map(&:to_s).map { |x| x.gsub(/\s{2,}/, ' ') }.map(&:strip).sort })
      end

      def failure_message
        "[doc #{@actual['id'].first}]"
      end

      def failure_message_when_negated
        "[doc #{@actual['id'].first}]"
      end

      def actual
        @actual.reject { |k, v| except_for.include? k }
      end
    end

    def be_kinda_like(*args)
      KindaLike.new(*args)
    end

    until $start >= $limit
      context "with docs (start: #{$start}, seed: #{RSpec.configuration.seed})", start: $start do

        it 'maps the same general output' do |example|
          # If you populate an index with all stored fields, this can be used to compare
          # the resulting output against the output from traject.

          url = "#{ENV['SOLRMARC_STORED_FIELDS_SOLR_BASE_URL']}/select?q=#{ENV.fetch('q', '*:*')}&fl=*&rows=#{$rows}&start=#{example.metadata[:start]}&wt=json&fl=*&sort=random#{RSpec.configuration.seed}+asc"
          response =  HTTP.get(url)
          docs = JSON.parse(response)['response']['docs']
          aggregate_failures do
            docs.each do |expected|
              record = MARC::XMLReader.new(StringIO.new(expected['marcxml'])).to_a.first
              actual = indexer.map_record(record).transform_values { |v| Array(v).map(&:to_s).map { |x| x.gsub(/\s{2,}/, ' ') }.map(&:strip).sort }

              expect(actual).to be_kinda_like expected, except_for: ignored_fields + pending_fields + %w[marcxml marcbib_xml]
            end
          end
        end
      end
      $start += $rows
    end
  end
end
